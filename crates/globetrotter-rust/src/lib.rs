#![allow(warnings)]

pub mod config;

pub use config::OutputConfig;

use convert_case::{Case, Casing};
use globetrotter_model as model;
use proc_macro2::{Ident, Span};
use quote::{ToTokens, format_ident, quote};
use std::sync::Arc;

#[must_use]
pub fn preamble() -> String {
    indoc::formatdoc!(
        r#"
            //
            // AUTOGENERATED. DO NOT EDIT.
            // generated by globetrotter v{version}.
            //
        "#,
        version = std::env!("CARGO_PKG_VERSION"),
    )
}

fn argument_to_rust_field_name(name: &str) -> String {
    let field_name = name.replace(' ', "").replace(['-', '.'], "_");
    field_name.to_case(Case::Snake)
}

fn key_to_rust_enum_variant(key: &str) -> String {
    let variant_name = key.replace(' ', "").replace(['-', '.'], "_");
    variant_name.to_case(Case::UpperCamel)
}

trait IntoTokenStream {
    fn into_token_stream(self) -> proc_macro2::TokenStream;
}

impl IntoTokenStream for model::ArgumentType {
    fn into_token_stream(self) -> proc_macro2::TokenStream {
        match self {
            Self::String => quote! {&'a str},
            Self::Number => quote! {i64},
            // TODO(roman): create our own globetrotter type for this
            Self::Iso8601DateTimeString => quote! {&'a str},
            Self::Any => quote! {serde_json::Value},
        }
    }
}

#[derive(thiserror::Error, Debug)]
pub struct DuplicateIdentifierError {
    identifier: String,
    keys: Vec<String>,
}

impl std::fmt::Display for DuplicateIdentifierError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "duplicate identifier `{}` (used by {})",
            self.identifier,
            self.keys.join(", ")
        )
    }
}

#[derive(thiserror::Error, Debug)]
pub struct DuplicateFieldError {
    field: String,
    enum_variant: String,
    arguments: Vec<String>,
    key: String,
}

impl std::fmt::Display for DuplicateFieldError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}: duplicate field `{}` used by arguments {} of variant `{}`",
            self.key,
            self.field,
            self.arguments
                .iter()
                .map(|arg| format!("{arg:?}"))
                .collect::<Vec<_>>()
                .join(", "),
            self.enum_variant,
        )
    }
}

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error(transparent)]
    DuplicateIdentifier(#[from] DuplicateIdentifierError),
    #[error(transparent)]
    DuplicateField(#[from] DuplicateFieldError),
    #[error("{0}")]
    Syn(String),
}

pub fn generate_translation_enum(translations: &model::Translations) -> Result<String, Error> {
    use itertools::Itertools;

    // can we use https://github.com/rust-phf/rust-phf at compile time?

    let enum_variant_names: Vec<_> = translations
        .0
        .iter()
        .map(|(key, translation)| (key_to_rust_enum_variant(key.as_ref()), key, translation))
        .collect();

    // find duplicate indentifiers
    let duplicates: Vec<_> = enum_variant_names
        .iter()
        .duplicates_by(|(safe_key, _, _)| safe_key)
        .collect();

    if !duplicates.is_empty() {
        let identifier = duplicates[0].0.to_string();
        let keys = duplicates
            .into_iter()
            .map(|(_, key, _)| key.to_string())
            .collect();
        return Err(DuplicateIdentifierError { identifier, keys }.into());
    }

    let enum_variants: Vec<_> = enum_variant_names
        .iter()
        .map(|(safe_key, key, translation)| {
            let fields: Vec<_> = translation
                .arguments
                .iter()
                .map(|(name, typ)| (argument_to_rust_field_name(name), name, typ))
                .collect();

            // check for duplicate field names
            let duplicates: Vec<_> = fields
                .iter()
                .duplicates_by(|(safe_name, _, _)| safe_name)
                .collect();

            if !duplicates.is_empty() {
                let field = duplicates[0].0.to_string();
                let arguments = duplicates
                    .into_iter()
                    .map(|(_, key, _)| (*key).to_string())
                    .collect();
                return Err(DuplicateFieldError {
                    field,
                    arguments,
                    enum_variant: safe_key.to_string(),
                    key: key.to_string(),
                }
                .into());
            }

            let fields: Vec<_> = fields
                .into_iter()
                .map(|(safe_name, name, typ)| {
                    let field_ident = format_ident!("{safe_name}");
                    let typ = typ.into_token_stream();
                    quote! {
                        #[serde(rename = #name)]
                        #field_ident: #typ,
                    }
                })
                .collect();

            let variant_name_ident = format_ident!("{safe_key}");
            Ok(quote! {
                #variant_name_ident {
                    #(#fields)*
                },
            })
        })
        .collect::<Result<Vec<_>, Error>>()?;

    let enum_variant_keys: Vec<_> = enum_variant_names
        .iter()
        .map(|(safe_key, key, _)| {
            let variant_name_ident = format_ident!("{safe_key}");
            let key = key.as_ref();
            quote! {
                Self::#variant_name_ident { .. } => #key,
            }
        })
        .collect();

    let out = quote! {
        #[derive(
            Debug, Clone, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize,
        )]
        #[serde(untagged)]
        pub enum Translation<'a> {
            #(#enum_variants)*
        }

        impl<'a> Translation<'a> {
            pub fn key(&self) -> &'static str {
                match self {
                    #(#enum_variant_keys)*
                }
            }
        }
    };
    let code = pretty_print(&out).map_err(|err| Error::Syn(err.to_string()))?;
    let code = format!("{}\n{}", preamble(), code);
    Ok(code)
}

fn pretty_print<T>(input: T) -> Result<String, syn::Error>
where
    T: quote::ToTokens,
{
    let file: syn::File = syn::parse2(quote! { #input })?;
    Ok(prettyplease::unparse(&file))
}

#[cfg(test)]
mod tests {
    use color_eyre::eyre;
    use globetrotter_model::{self as model, diagnostics::Spanned};
    use similar_asserts::assert_eq as sim_assert_eq;

    static INIT: std::sync::Once = std::sync::Once::new();

    /// Initialize test
    ///
    /// This ensures `color_eyre` is setup once.
    pub fn init() {
        INIT.call_once(|| {
            color_eyre::install().ok();
        });
    }

    #[test]
    fn generate_enum() -> eyre::Result<()> {
        crate::tests::init();

        let translations = [
            (
                Spanned::dummy("test.one".to_string()),
                model::Translation {
                    language: [(
                        model::Language::En,
                        Spanned::dummy("test.one in en".to_string()),
                    )]
                    .into_iter()
                    .collect(),
                    arguments: [].into_iter().collect(),
                    file_id: 0,
                },
            ),
            (
                Spanned::dummy("test.two".to_string()),
                model::Translation {
                    language: [(
                        model::Language::En,
                        Spanned::dummy("test.two in en".to_string()),
                    )]
                    .into_iter()
                    .collect(),
                    arguments: [
                        ("arg-one".to_string(), model::ArgumentType::String),
                        ("ArgTwo".to_string(), model::ArgumentType::Number),
                        ("Arg_Three".to_string(), model::ArgumentType::Any),
                    ]
                    .into_iter()
                    .collect(),
                    file_id: 0,
                },
            ),
        ];
        let translations = model::Translations(translations.into_iter().collect());
        let have = super::generate_translation_enum(&translations)?;
        println!("{have}");

        let want = indoc::indoc! {r#"
            #[derive(
                Debug,
                Clone,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                serde::Serialize,
                serde::Deserialize,
            )]
            #[serde(untagged)]
            pub enum Translation<'a> {
                TestOne {},
                TestTwo {
                    #[serde(rename = "arg-one")]
                    arg_one: &'a str,
                    #[serde(rename = "ArgTwo")]
                    arg_two: i64,
                    #[serde(rename = "Arg_Three")]
                    arg_three: serde_json::Value,
                },
            }
            impl<'a> Translation<'a> {
                pub fn key(&self) -> &'static str {
                    match self {
                        Self::TestOne { .. } => "test.one",
                        Self::TestTwo { .. } => "test.two",
                    }
                }
            }
        "# };
        let want = format!("{}\n{}", super::preamble(), want);
        sim_assert_eq!(have: have, want: want);
        Ok(())
    }
}
